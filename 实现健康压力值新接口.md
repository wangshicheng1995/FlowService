# 实现健康压力值新接口

你现在是 FlowService 的后端开发，请在现有代码结构中实现一个「健康压力值」(score) 的计算接口，供 Flow App 首页状态栏显示用户当天的健康压力值。

# 1. 目标与接口

- 这是一个 **MVP** 版本，实现要尽量简单。
- 需要一个只读接口（例如）：GET /api/health/load-score
- 返回体只有两个字段：
    
    ```java
    {
      "userId": "xxx",
      "score": 72
    }
    ```
    
- userId 从现有的认证体系里取（例如 @AuthenticationPrincipal），
- score 为当前用户指定日期（默认今天）的健康压力值，范围 0–100，前端用这个值来画状态栏和虚线位置。

# 2. 基本思路

1. 我们已经有按「餐」存储的数据（比如 meal_records / meal_nutrition），每条记录里含有一组标签，比如：
    1. 风险标签：HIGH_SODIUM, HIGH_SUGAR, LOW_FIBER, HIGH_SAT_FAT, HIGH_ENERGY_DENSE, PROCESSED_MEAT, DEEP_FRIED, SUGARY_DRINK
    2. 保护标签：HIGH_FIBER_MEAL, VEGETABLE_RICH, LEAN_PROTEIN, BALANCED_MEAL （这个没有，需要你来创建）
2. 每次接口被调用时：
    1. 查询「某用户在某一天（默认今天）」已吃过的所有餐及其标签，按时间顺序排序
    2. 从一个初始值 score = 40 开始，逐餐累加或扣减；
    3. 最终得到今天的 score，返回给前端。

# **3. 计算规则（务必按此实现）**

## **3.1 score 的范围和初始值**

- score 整体范围：0–100（int）
- 当某天**没有任何用餐记录**时：
    - 直接返回：score = 40
    - 这是状态栏虚线的初始位置。

## **3.2 单餐对 score 的影响（重要）**

先根据标签算出这一餐的「净风险指数」，只用**计数**，逻辑尽量简单：

1. 定义两组常量（可以用 enum 或常量集合）：
    - RISK_TAGS = { HIGH_SODIUM, HIGH_SUGAR, LOW_FIBER, HIGH_SAT_FAT, HIGH_ENERGY_DENSE, PROCESSED_MEAT, DEEP_FRIED, SUGARY_DRINK }
    - PROTECTIVE_TAGS = { HIGH_FIBER_MEAL, VEGETABLE_RICH, LEAN_PROTEIN, BALANCED_MEAL }
2. 对于某一餐：
    - riskCount = 该餐中命中的风险标签数量
    - protectCount = 该餐中命中的保护标签数量
    - netRisk = riskCount - protectCount
3. 根据 netRisk 映射出这顿饭对 score 的增减值 delta（单位：分）：
    
    
    | **netRisk 条件** | **解释** | **delta** |
    | --- | --- | --- |
    | netRisk >= 3 | 非常不健康 / 重口味炸弹餐 | +20 |
    | netRisk == 2 | 明显偏不健康 | +15 |
    | netRisk == 1 | 略微偏不健康 | +10 |
    | netRisk == 0 | 基本中性，既不加也不减 | 0 |
    | netRisk == -1 or -2 | 比较健康 | -10 |
    | netRisk <= -3 | 非常健康的轻食 / 沙拉等 | -20 |

这样设计的结果是：

- 如果用户**连续三顿都是很不健康**（netRisk >= 3），从初始 40 开始，每顿 +20，三顿之后大致会落在 90–100 区间；
- 如果前面两顿不健康把 score 累积到 80 左右，晚饭吃了一顿非常健康的轻食（netRisk <= -3），就会 -20，把 score 拉回到 60 左右，接近健康水平。

**3.3 一天内的累计流程**

**伪代码示意：**

```java
int calculateDailyScore(String userId, LocalDate date) {
    List<Meal> meals = mealRepository.findByUserIdAndDateOrderByTime(userId, date);

    if (meals.isEmpty()) {
        return 40; // 初始值
    }

    int score = 40;

    for (Meal meal : meals) {
        int delta = calculateDeltaByTags(meal.getTags()); // 按 3.2 的规则
        score += delta;

        // 限制在 0-100 之间
        if (score > 100) score = 100;
        if (score < 0) score = 0;
    }

    return score;
}
```

calculateDeltaByTags(...) 请严格按照上面 netRisk → delta 的表来实现。

## **4. Controller 层**

- 新建一个简单的 Controller 方法，例如：
    
    ```java
    @GetMapping("/api/health/load-score")
    public HealthLoadScoreResponse getHealthLoadScore(
            @AuthenticationPrincipal UserAuth auth,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date
    ) {
        LocalDate targetDate = (date != null) ? date : LocalDate.now();
        String userId = auth.getUserId();
        int score = healthLoadService.calculateDailyScore(userId, targetDate);
        return new HealthLoadScoreResponse(userId, score);
    }
    ```
    
- HealthLoadScoreResponse 只包含：
    
    ```java
    public class HealthLoadScoreResponse {
        private String userId;
        private int score;
    }
    ```
    

请根据以上说明在 FlowService 中新增相应的 Service、Repository 查询（如需）、Controller 和测试用例。前端只会使用 score 字段来绘制首页状态栏的虚线位置。